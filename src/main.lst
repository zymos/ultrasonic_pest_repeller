GAS LISTING /tmp/ccycqgnB.s 			page 1


   1               		.file	"main.c"
   2               	__SP_L__ = 0x3d
   3               	__SREG__ = 0x3f
   4               	__tmp_reg__ = 0
   5               	__zero_reg__ = 1
   6               		.stabs	"/mnt/data10tb/Online Storage/Zoho Docs/Documents/Projects/Embedded/crawspace_moms_house/sr
   7               		.stabs	"main.c",100,0,2,.Ltext0
   8               		.text
   9               	.Ltext0:
  10               		.stabs	"gcc2_compiled.",60,0,0,0
  11               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  12               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,0,0
  13               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  14               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  15               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  16               		.stabs	"__int128:t(0,6)=@s128;r(0,6);02000000000000000000000000000000000000000000;0177777777777777
  17               		.stabs	"__int128 unsigned:t(0,7)=@s128;r(0,7);0;03777777777777777777777777777777777777777777;",128
  18               		.stabs	"long long int:t(0,8)=@s64;r(0,8);01000000000000000000000;00777777777777777777777;",128,0,0
  19               		.stabs	"long long unsigned int:t(0,9)=@s64;r(0,9);0;01777777777777777777777;",128,0,0,0
  20               		.stabs	"short int:t(0,10)=r(0,10);-32768;32767;",128,0,0,0
  21               		.stabs	"short unsigned int:t(0,11)=r(0,11);0;0177777;",128,0,0,0
  22               		.stabs	"signed char:t(0,12)=@s8;r(0,12);-128;127;",128,0,0,0
  23               		.stabs	"unsigned char:t(0,13)=@s8;r(0,13);0;255;",128,0,0,0
  24               		.stabs	"float:t(0,14)=r(0,1);4;0;",128,0,0,0
  25               		.stabs	"double:t(0,15)=r(0,1);4;0;",128,0,0,0
  26               		.stabs	"long double:t(0,16)=r(0,1);4;0;",128,0,0,0
  27               		.stabs	"short _Fract:t(0,17)=r(0,1);1;0;",128,0,0,0
  28               		.stabs	"_Fract:t(0,18)=r(0,1);2;0;",128,0,0,0
  29               		.stabs	"long _Fract:t(0,19)=r(0,1);4;0;",128,0,0,0
  30               		.stabs	"long long _Fract:t(0,20)=r(0,1);8;0;",128,0,0,0
  31               		.stabs	"unsigned short _Fract:t(0,21)=r(0,1);1;0;",128,0,0,0
  32               		.stabs	"unsigned _Fract:t(0,22)=r(0,1);2;0;",128,0,0,0
  33               		.stabs	"unsigned long _Fract:t(0,23)=r(0,1);4;0;",128,0,0,0
  34               		.stabs	"unsigned long long _Fract:t(0,24)=r(0,1);8;0;",128,0,0,0
  35               		.stabs	"_Sat short _Fract:t(0,25)=r(0,1);1;0;",128,0,0,0
  36               		.stabs	"_Sat _Fract:t(0,26)=r(0,1);2;0;",128,0,0,0
  37               		.stabs	"_Sat long _Fract:t(0,27)=r(0,1);4;0;",128,0,0,0
  38               		.stabs	"_Sat long long _Fract:t(0,28)=r(0,1);8;0;",128,0,0,0
  39               		.stabs	"_Sat unsigned short _Fract:t(0,29)=r(0,1);1;0;",128,0,0,0
  40               		.stabs	"_Sat unsigned _Fract:t(0,30)=r(0,1);2;0;",128,0,0,0
  41               		.stabs	"_Sat unsigned long _Fract:t(0,31)=r(0,1);4;0;",128,0,0,0
  42               		.stabs	"_Sat unsigned long long _Fract:t(0,32)=r(0,1);8;0;",128,0,0,0
  43               		.stabs	"short _Accum:t(0,33)=r(0,1);2;0;",128,0,0,0
  44               		.stabs	"_Accum:t(0,34)=r(0,1);4;0;",128,0,0,0
  45               		.stabs	"long _Accum:t(0,35)=r(0,1);8;0;",128,0,0,0
  46               		.stabs	"long long _Accum:t(0,36)=r(0,1);8;0;",128,0,0,0
  47               		.stabs	"unsigned short _Accum:t(0,37)=r(0,1);2;0;",128,0,0,0
  48               		.stabs	"unsigned _Accum:t(0,38)=r(0,1);4;0;",128,0,0,0
  49               		.stabs	"unsigned long _Accum:t(0,39)=r(0,1);8;0;",128,0,0,0
  50               		.stabs	"unsigned long long _Accum:t(0,40)=r(0,1);8;0;",128,0,0,0
  51               		.stabs	"_Sat short _Accum:t(0,41)=r(0,1);2;0;",128,0,0,0
  52               		.stabs	"_Sat _Accum:t(0,42)=r(0,1);4;0;",128,0,0,0
  53               		.stabs	"_Sat long _Accum:t(0,43)=r(0,1);8;0;",128,0,0,0
  54               		.stabs	"_Sat long long _Accum:t(0,44)=r(0,1);8;0;",128,0,0,0
  55               		.stabs	"_Sat unsigned short _Accum:t(0,45)=r(0,1);2;0;",128,0,0,0
  56               		.stabs	"_Sat unsigned _Accum:t(0,46)=r(0,1);4;0;",128,0,0,0
  57               		.stabs	"_Sat unsigned long _Accum:t(0,47)=r(0,1);8;0;",128,0,0,0
GAS LISTING /tmp/ccycqgnB.s 			page 2


  58               		.stabs	"_Sat unsigned long long _Accum:t(0,48)=r(0,1);8;0;",128,0,0,0
  59               		.stabs	"void:t(0,49)=(0,49)",128,0,0,0
  60               		.stabs	"/usr/lib/avr/include/avr/io.h",130,0,0,0
  61               		.stabs	"/usr/lib/avr/include/avr/sfr_defs.h",130,0,0,0
  62               		.stabs	"/usr/lib/avr/include/inttypes.h",130,0,0,0
  63               		.stabs	"/usr/lib/gcc/avr/5.4.0/include/stdint.h",130,0,0,0
  64               		.stabs	"/usr/lib/avr/include/stdint.h",130,0,0,0
  65               		.stabs	"int8_t:t(5,1)=(0,12)",128,0,125,0
  66               		.stabs	"uint8_t:t(5,2)=(0,13)",128,0,126,0
  67               		.stabs	"int16_t:t(5,3)=(0,1)",128,0,127,0
  68               		.stabs	"uint16_t:t(5,4)=(0,4)",128,0,128,0
  69               		.stabs	"int32_t:t(5,5)=(0,3)",128,0,129,0
  70               		.stabs	"uint32_t:t(5,6)=(0,5)",128,0,130,0
  71               		.stabs	"int64_t:t(5,7)=(0,8)",128,0,132,0
  72               		.stabs	"uint64_t:t(5,8)=(0,9)",128,0,133,0
  73               		.stabs	"intptr_t:t(5,9)=(5,3)",128,0,146,0
  74               		.stabs	"uintptr_t:t(5,10)=(5,4)",128,0,151,0
  75               		.stabs	"int_least8_t:t(5,11)=(5,1)",128,0,163,0
  76               		.stabs	"uint_least8_t:t(5,12)=(5,2)",128,0,168,0
  77               		.stabs	"int_least16_t:t(5,13)=(5,3)",128,0,173,0
  78               		.stabs	"uint_least16_t:t(5,14)=(5,4)",128,0,178,0
  79               		.stabs	"int_least32_t:t(5,15)=(5,5)",128,0,183,0
  80               		.stabs	"uint_least32_t:t(5,16)=(5,6)",128,0,188,0
  81               		.stabs	"int_least64_t:t(5,17)=(5,7)",128,0,196,0
  82               		.stabs	"uint_least64_t:t(5,18)=(5,8)",128,0,203,0
  83               		.stabs	"int_fast8_t:t(5,19)=(5,1)",128,0,217,0
  84               		.stabs	"uint_fast8_t:t(5,20)=(5,2)",128,0,222,0
  85               		.stabs	"int_fast16_t:t(5,21)=(5,3)",128,0,227,0
  86               		.stabs	"uint_fast16_t:t(5,22)=(5,4)",128,0,232,0
  87               		.stabs	"int_fast32_t:t(5,23)=(5,5)",128,0,237,0
  88               		.stabs	"uint_fast32_t:t(5,24)=(5,6)",128,0,242,0
  89               		.stabs	"int_fast64_t:t(5,25)=(5,7)",128,0,250,0
  90               		.stabs	"uint_fast64_t:t(5,26)=(5,8)",128,0,257,0
  91               		.stabs	"intmax_t:t(5,27)=(5,7)",128,0,277,0
  92               		.stabs	"uintmax_t:t(5,28)=(5,8)",128,0,282,0
  93               		.stabn	162,0,0,0
  94               		.stabn	162,0,0,0
  95               		.stabs	"int_farptr_t:t(3,1)=(5,5)",128,0,77,0
  96               		.stabs	"uint_farptr_t:t(3,2)=(5,6)",128,0,81,0
  97               		.stabn	162,0,0,0
  98               		.stabn	162,0,0,0
  99               		.stabs	"/usr/lib/avr/include/avr/fuse.h",130,0,0,0
 100               		.stabs	"__fuse_t:t(6,1)=(6,2)=s2low:(0,13),0,8;high:(0,13),8,8;;",128,0,252,0
 101               		.stabn	162,0,0,0
 102               		.stabn	162,0,0,0
 103               		.stabs	"animal_det:F(0,49)",36,0,77,animal_det
 104               	.global	animal_det
 105               		.type	animal_det, @function
 106               	animal_det:
 107               		.stabd	46,0,0
   1:main.c        **** /*
   2:main.c        ****  * Animal Deturent Ultrasonic Beeper and Flasher
   3:main.c        ****  *
   4:main.c        ****  *    Description: really annoy (hopfully) for pests,
   5:main.c        ****  *       random ultrasonic beeps, 2-tone, and flashes
   6:main.c        ****  *       Code is for Attiny26, but should be easly modified to any AVR
   7:main.c        ****  *    
GAS LISTING /tmp/ccycqgnB.s 			page 3


   8:main.c        ****  *    Credits: Zef the Tinker, 2023/11
   9:main.c        ****  *
  10:main.c        ****  */ 
  11:main.c        **** 
  12:main.c        **** // define the frequency
  13:main.c        **** #define	F_CPU	1000000
  14:main.c        **** #define 	XTAL   1000000
  15:main.c        **** #define __AVR_ATtiny26__ 1 // to use other MCU you need to change this
  16:main.c        **** 
  17:main.c        **** 
  18:main.c        **** // #include <stdlib.h>
  19:main.c        **** #include <avr/io.h>
  20:main.c        **** // #include <avr/pgmspace.h>
  21:main.c        **** #include <util/delay.h>
  22:main.c        **** #include <avr/interrupt.h>
  23:main.c        **** 
  24:main.c        **** 
  25:main.c        **** 
  26:main.c        **** /////////////////////////////////////////////////////////////////////////////
  27:main.c        **** // PINS
  28:main.c        **** //    if you use other MCU you need to change this
  29:main.c        **** #define PIN_SPEAK0 PA6 // ultra-sonic speaker0
  30:main.c        **** #define PIN_SPEAK1 PA7 // ultra-sonic speaker1
  31:main.c        **** #define PIN_LED0 PA5 // flashing LED
  32:main.c        **** #define PIN_LED_PWR_ON PA4 // LED to indicate MCU is up and running
  33:main.c        **** 
  34:main.c        **** // PB6 is set to INT0 interrupt
  35:main.c        **** 
  36:main.c        **** 
  37:main.c        **** 
  38:main.c        **** 
  39:main.c        **** 
  40:main.c        **** 
  41:main.c        **** 
  42:main.c        **** //////////////////////////////////////////////////////////////////////////////
  43:main.c        **** // Global vars
  44:main.c        **** //
  45:main.c        **** const int beep_length[10] = {1,7,3,4,6,2,4,8,2,5}; // list of random duration
  46:main.c        **** #define delay_multi 50 // multiplier for the 1ms delay
  47:main.c        **** #define sleep_delay_multi 500 // multiplier for delay between auto-activate
  48:main.c        **** 
  49:main.c        **** #define NUM_OF_LOOPS 20 // number of times to loop array
  50:main.c        **** 
  51:main.c        **** 
  52:main.c        **** 
  53:main.c        **** 
  54:main.c        **** //////////////////////////////////////////////////////////////////////////////
  55:main.c        **** // Code
  56:main.c        **** //
  57:main.c        **** 
  58:main.c        **** 
  59:main.c        **** // make sure the freq isnt redefine
  60:main.c        **** #ifdef F_CPU
  61:main.c        ****    #undef F_CPU
  62:main.c        **** #endif
  63:main.c        **** #define F_CPU	1000000
  64:main.c        **** 
GAS LISTING /tmp/ccycqgnB.s 			page 4


  65:main.c        **** #ifdef XTAL
  66:main.c        ****    #undef XTAL
  67:main.c        **** #endif
  68:main.c        **** #define XTAL   1000000
  69:main.c        **** 
  70:main.c        **** 
  71:main.c        **** 
  72:main.c        **** //////////////////////////////
  73:main.c        **** // Animal Deturent function
  74:main.c        **** //    beeps and flashes, 
  75:main.c        **** //    psuedo random durration and pauses
  76:main.c        **** //    
  77:main.c        **** void animal_det(void){
 108               		.stabn	68,0,77,.LM0-.LFBB1
 109               	.LM0:
 110               	.LFBB1:
 111 0000 EF92      		push r14
 112 0002 FF92      		push r15
 113 0004 0F93      		push r16
 114 0006 1F93      		push r17
 115 0008 CF93      		push r28
 116 000a DF93      		push r29
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 6 */
 120               	.L__stack_usage = 6
 121               	.LBB13:
 122               	.LBB14:
 123               	.LBB15:
  78:main.c        ****    int pointer1 = 5; // used for speaker1 as random num list offset
  79:main.c        **** 
  80:main.c        ****    // repeat loops of array
  81:main.c        ****    for(int q=0; q<NUM_OF_LOOPS; q++){
  82:main.c        ****       // loop the psuedo-radom array
  83:main.c        ****       //  this beep for each number in array
  84:main.c        ****       for(int x=0; x < sizeof(beep_length)/sizeof(beep_length[0]); x++){ //loop the array
  85:main.c        ****      
  86:main.c        ****          // Speakers
  87:main.c        ****          PORTA &= ~(1 << PIN_SPEAK0); //speaker 0 off
  88:main.c        ****          PORTA &= ~(1 << PIN_SPEAK1); //speaker 1 off
  89:main.c        ****          for(int n=0; n<10; n++){ //on/off period
  90:main.c        ****             if(pointer1 == 10){ // for ponter1 offset
  91:main.c        ****                pointer1 = 0;
 124               		.stabn	68,0,91,.LM1-.LFBB1
 125               	.LM1:
 126 000c 04E1      		ldi r16,lo8(20)
 127 000e 10E0      		ldi r17,0
 128               	.LBE15:
 129               	.LBE14:
 130               	.LBE13:
  78:main.c        ****    int pointer1 = 5; // used for speaker1 as random num list offset
 131               		.stabn	68,0,78,.LM2-.LFBB1
 132               	.LM2:
 133 0010 25E0      		ldi r18,lo8(5)
 134 0012 30E0      		ldi r19,0
 135               	.LBB25:
 136               	.LBB21:
GAS LISTING /tmp/ccycqgnB.s 			page 5


  92:main.c        ****             }
  93:main.c        ****             if(n > beep_length[x]){
  94:main.c        ****                PORTA |= (1 << PIN_SPEAK0); //speaker 0 on
  95:main.c        ****             }
  96:main.c        ****             if(n > beep_length[pointer1]){
  97:main.c        ****                PORTA |= (1 << PIN_SPEAK1); //speaker 1 on
  98:main.c        ****             }
  99:main.c        ****             _delay_ms(1 * delay_multi); 
 100:main.c        ****          }   
 101:main.c        **** 
 102:main.c        ****          //LED
 103:main.c        ****          if(x % 5 == 0){ // activate LED every 5 beeps
 137               		.stabn	68,0,103,.LM3-.LFBB1
 138               	.LM3:
 139 0014 55E0      		ldi r21,lo8(5)
 140 0016 E52E      		mov r14,r21
 141 0018 F12C      		mov r15,__zero_reg__
 142               	.L2:
 143 001a C0E0      		ldi r28,lo8(beep_length)
 144 001c D0E0      		ldi r29,hi8(beep_length)
 145               	.LBE21:
 146               	.LBE25:
  77:main.c        ****    int pointer1 = 5; // used for speaker1 as random num list offset
 147               		.stabn	68,0,77,.LM4-.LFBB1
 148               	.LM4:
 149 001e E0E0      		ldi r30,0
 150 0020 F0E0      		ldi r31,0
 151               	.L8:
 152               	.LBB26:
 153               	.LBB22:
  87:main.c        ****          PORTA &= ~(1 << PIN_SPEAK1); //speaker 1 off
 154               		.stabn	68,0,87,.LM5-.LFBB1
 155               	.LM5:
 156 0022 DE98      		cbi 0x1b,6
  88:main.c        ****          for(int n=0; n<10; n++){ //on/off period
 157               		.stabn	68,0,88,.LM6-.LFBB1
 158               	.LM6:
 159 0024 DF98      		cbi 0x1b,7
 160               	.LBB18:
  89:main.c        ****             if(pointer1 == 10){ // for ponter1 offset
 161               		.stabn	68,0,89,.LM7-.LFBB1
 162               	.LM7:
 163 0026 80E0      		ldi r24,0
 164 0028 90E0      		ldi r25,0
 165               	.L6:
  90:main.c        ****                pointer1 = 0;
 166               		.stabn	68,0,90,.LM8-.LFBB1
 167               	.LM8:
 168 002a 2A30      		cpi r18,10
 169 002c 3105      		cpc r19,__zero_reg__
 170 002e 01F4      		brne .L3
  91:main.c        ****             }
 171               		.stabn	68,0,91,.LM9-.LFBB1
 172               	.LM9:
 173 0030 20E0      		ldi r18,0
 174 0032 30E0      		ldi r19,0
 175               	.L3:
GAS LISTING /tmp/ccycqgnB.s 			page 6


  93:main.c        ****                PORTA |= (1 << PIN_SPEAK0); //speaker 0 on
 176               		.stabn	68,0,93,.LM10-.LFBB1
 177               	.LM10:
 178 0034 4881      		ld r20,Y
 179 0036 5981      		ldd r21,Y+1
 180 0038 4817      		cp r20,r24
 181 003a 5907      		cpc r21,r25
 182 003c 04F4      		brge .L4
  94:main.c        ****             }
 183               		.stabn	68,0,94,.LM11-.LFBB1
 184               	.LM11:
 185 003e DE9A      		sbi 0x1b,6
 186               	.L4:
  96:main.c        ****                PORTA |= (1 << PIN_SPEAK1); //speaker 1 on
 187               		.stabn	68,0,96,.LM12-.LFBB1
 188               	.LM12:
 189 0040 A22F      		mov r26,r18
 190 0042 B32F      		mov r27,r19
 191 0044 AA0F      		lsl r26
 192 0046 BB1F      		rol r27
 193 0048 A050      		subi r26,lo8(-(beep_length))
 194 004a B040      		sbci r27,hi8(-(beep_length))
 195 004c 4D91      		ld r20,X+
 196 004e 5C91      		ld r21,X
 197 0050 4817      		cp r20,r24
 198 0052 5907      		cpc r21,r25
 199 0054 04F4      		brge .L5
  97:main.c        ****             }
 200               		.stabn	68,0,97,.LM13-.LFBB1
 201               	.LM13:
 202 0056 DF9A      		sbi 0x1b,7
 203               	.L5:
 204               	.LBB16:
 205               	.LBB17:
 206               		.stabs	"/usr/lib/avr/include/util/delay.h",132,0,0,.Ltext1
 207               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
GAS LISTING /tmp/ccycqgnB.s 			page 7


  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
GAS LISTING /tmp/ccycqgnB.s 			page 8


  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
GAS LISTING /tmp/ccycqgnB.s 			page 9


 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 208               		.stabn	68,0,187,.LM14-.LFBB1
 209               	.LM14:
 210 0058 A3ED      		ldi r26,lo8(12499)
 211 005a B0E3      		ldi r27,hi8(12499)
 212 005c 1197      	1:	sbiw r26,1
GAS LISTING /tmp/ccycqgnB.s 			page 10


 213 005e 01F4      		brne 1b
 214 0060 00C0      		rjmp .
 215 0062 0000      		nop
 216               	.LBE17:
 217               	.LBE16:
 218               		.stabs	"main.c",132,0,0,.Ltext2
 219               	.Ltext2:
  89:main.c        ****             if(pointer1 == 10){ // for ponter1 offset
 220               		.stabn	68,0,89,.LM15-.LFBB1
 221               	.LM15:
 222 0064 0196      		adiw r24,1
 223 0066 8A30      		cpi r24,10
 224 0068 9105      		cpc r25,__zero_reg__
 225 006a 01F4      		brne .L6
 226               	.LBE18:
 227               		.stabn	68,0,103,.LM16-.LFBB1
 228               	.LM16:
 229 006c 8E2F      		mov r24,r30
 230 006e 9F2F      		mov r25,r31
 231 0070 6E2D      		mov r22,r14
 232 0072 7F2D      		mov r23,r15
 233 0074 00D0      		rcall __divmodhi4
 234 0076 892B      		or r24,r25
 235 0078 01F4      		brne .L7
 104:main.c        ****             PORTA |= (1 << PIN_LED0); //led on
 236               		.stabn	68,0,104,.LM17-.LFBB1
 237               	.LM17:
 238 007a DD9A      		sbi 0x1b,5
 239               	.LBB19:
 240               	.LBB20:
 241               		.stabs	"/usr/lib/avr/include/util/delay.h",132,0,0,.Ltext3
 242               	.Ltext3:
 243               		.stabn	68,0,187,.LM18-.LFBB1
 244               	.LM18:
 245 007c BFE9      		ldi r27,lo8(99999)
 246 007e 46E8      		ldi r20,hi8(99999)
 247 0080 81E0      		ldi r24,hlo8(99999)
 248 0082 B150      	1:	subi r27,1
 249 0084 4040      		sbci r20,0
 250 0086 8040      		sbci r24,0
 251 0088 01F4      		brne 1b
 252 008a 00C0      		rjmp .
 253 008c 0000      		nop
 254               	.LBE20:
 255               	.LBE19:
 256               		.stabs	"main.c",132,0,0,.Ltext4
 257               	.Ltext4:
 105:main.c        ****             _delay_ms(10 * delay_multi); 
 106:main.c        ****             PORTA &= ~(1 << PIN_LED0); //led off
 258               		.stabn	68,0,106,.LM19-.LFBB1
 259               	.LM19:
 260 008e DD98      		cbi 0x1b,5
 261               	.L7:
 107:main.c        ****             // _delay_ms(1 * delay_multi);
 108:main.c        ****          }
 109:main.c        **** 
 110:main.c        ****          // inc pointer for speaker1
GAS LISTING /tmp/ccycqgnB.s 			page 11


 111:main.c        ****          pointer1++;
 262               		.stabn	68,0,111,.LM20-.LFBB1
 263               	.LM20:
 264 0090 2F5F      		subi r18,-1
 265 0092 3F4F      		sbci r19,-1
  84:main.c        ****      
 266               		.stabn	68,0,84,.LM21-.LFBB1
 267               	.LM21:
 268 0094 3196      		adiw r30,1
 269 0096 2296      		adiw r28,2
 270 0098 EA30      		cpi r30,10
 271 009a F105      		cpc r31,__zero_reg__
 272 009c 01F4      		brne .L8
 273               	.LBE22:
 112:main.c        ****       }
 113:main.c        ****       
 114:main.c        ****       // LED flashes
 115:main.c        ****       PORTA &= ~(1 << PIN_LED0); //led 0 off
 274               		.stabn	68,0,115,.LM22-.LFBB1
 275               	.LM22:
 276 009e DD98      		cbi 0x1b,5
 116:main.c        ****       PORTA &= ~(1 << PIN_SPEAK0); //speaker 0 off
 277               		.stabn	68,0,116,.LM23-.LFBB1
 278               	.LM23:
 279 00a0 DE98      		cbi 0x1b,6
 117:main.c        ****       PORTA &= ~(1 << PIN_SPEAK1); //speaker 1 off
 280               		.stabn	68,0,117,.LM24-.LFBB1
 281               	.LM24:
 282 00a2 DF98      		cbi 0x1b,7
 283               	.LBB23:
 284               	.LBB24:
 285               		.stabs	"/usr/lib/avr/include/util/delay.h",132,0,0,.Ltext5
 286               	.Ltext5:
 287               		.stabn	68,0,187,.LM25-.LFBB1
 288               	.LM25:
 289 00a4 ABE7      		ldi r26,lo8(-28037)
 290 00a6 B2E9      		ldi r27,hi8(-28037)
 291 00a8 1197      	1:	sbiw r26,1
 292 00aa 01F4      		brne 1b
 293 00ac 00C0      		rjmp .
 294 00ae 0000      		nop
 295 00b0 0150      		subi r16,1
 296 00b2 1109      		sbc r17,__zero_reg__
 297               	.LBE24:
 298               	.LBE23:
 299               		.stabs	"main.c",132,0,0,.Ltext6
 300               	.Ltext6:
  81:main.c        ****       // loop the psuedo-radom array
 301               		.stabn	68,0,81,.LM26-.LFBB1
 302               	.LM26:
 303 00b4 01F0      		breq .+2
 304 00b6 00C0      		rjmp .L2
 305               	/* epilogue start */
 306               	.LBE26:
 118:main.c        **** 
 119:main.c        ****       _delay_ms(3 * delay_multi);
 120:main.c        ****    }
GAS LISTING /tmp/ccycqgnB.s 			page 12


 121:main.c        **** }
 307               		.stabn	68,0,121,.LM27-.LFBB1
 308               	.LM27:
 309 00b8 DF91      		pop r29
 310 00ba CF91      		pop r28
 311 00bc 1F91      		pop r17
 312 00be 0F91      		pop r16
 313 00c0 FF90      		pop r15
 314 00c2 EF90      		pop r14
 315 00c4 0895      		ret
 316               		.size	animal_det, .-animal_det
 317               		.stabs	"pointer1:r(0,1)",64,0,78,18
 318               		.stabn	192,0,0,.LFBB1-.LFBB1
 319               		.stabs	"x:r(0,1)",64,0,84,30
 320               		.stabn	192,0,0,.LBB14-.LFBB1
 321               		.stabs	"n:r(0,1)",64,0,89,24
 322               		.stabn	192,0,0,.LBB15-.LFBB1
 323               		.stabn	224,0,0,.LBE15-.LFBB1
 324               		.stabs	"n:r(0,1)",64,0,89,24
 325               		.stabn	192,0,0,.LBB18-.LFBB1
 326               		.stabn	224,0,0,.LBE18-.LFBB1
 327               		.stabn	224,0,0,.LBE14-.LFBB1
 328               		.stabs	"x:r(0,1)",64,0,84,30
 329               		.stabn	192,0,0,.LBB21-.LFBB1
 330               		.stabn	224,0,0,.LBE21-.LFBB1
 331               		.stabs	"x:r(0,1)",64,0,84,30
 332               		.stabn	192,0,0,.LBB22-.LFBB1
 333               		.stabn	224,0,0,.LBE22-.LFBB1
 334               		.stabn	224,0,0,.Lscope1-.LFBB1
 335               	.Lscope1:
 336               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 337               		.stabd	78,0,0
 338               		.stabs	"__vector_1:F(0,49)",36,0,127,__vector_1
 339               	.global	__vector_1
 340               		.type	__vector_1, @function
 341               	__vector_1:
 342               		.stabd	46,0,0
 122:main.c        **** 
 123:main.c        **** ////////////////////////////
 124:main.c        **** // Interrupt on INT0
 125:main.c        **** //  to use other MCU you need to change this
 126:main.c        **** 
 127:main.c        **** ISR(INT0_vect){
 343               		.stabn	68,0,127,.LM28-.LFBB2
 344               	.LM28:
 345               	.LFBB2:
 346 00c6 1F92      		push r1
 347 00c8 0F92      		push r0
 348 00ca 0FB6      		in r0,__SREG__
 349 00cc 0F92      		push r0
 350 00ce 1124      		clr __zero_reg__
 351 00d0 2F93      		push r18
 352 00d2 3F93      		push r19
 353 00d4 4F93      		push r20
 354 00d6 5F93      		push r21
 355 00d8 6F93      		push r22
 356 00da 7F93      		push r23
GAS LISTING /tmp/ccycqgnB.s 			page 13


 357 00dc 8F93      		push r24
 358 00de 9F93      		push r25
 359 00e0 AF93      		push r26
 360 00e2 BF93      		push r27
 361 00e4 EF93      		push r30
 362 00e6 FF93      		push r31
 363               	/* prologue: Signal */
 364               	/* frame size = 0 */
 365               	/* stack size = 15 */
 366               	.L__stack_usage = 15
 128:main.c        ****    // See:
 129:main.c        ****    // https://onlinedocs.microchip.com/pr/GUID-317042D4-BCCE-4065-BB05-AC4312DBC2C4-en-US-2/index.h
 130:main.c        ****    animal_det();
 367               		.stabn	68,0,130,.LM29-.LFBB2
 368               	.LM29:
 369 00e8 00D0      		rcall animal_det
 370               	/* epilogue start */
 131:main.c        **** }
 371               		.stabn	68,0,131,.LM30-.LFBB2
 372               	.LM30:
 373 00ea FF91      		pop r31
 374 00ec EF91      		pop r30
 375 00ee BF91      		pop r27
 376 00f0 AF91      		pop r26
 377 00f2 9F91      		pop r25
 378 00f4 8F91      		pop r24
 379 00f6 7F91      		pop r23
 380 00f8 6F91      		pop r22
 381 00fa 5F91      		pop r21
 382 00fc 4F91      		pop r20
 383 00fe 3F91      		pop r19
 384 0100 2F91      		pop r18
 385 0102 0F90      		pop r0
 386 0104 0FBE      		out __SREG__,r0
 387 0106 0F90      		pop r0
 388 0108 1F90      		pop r1
 389 010a 1895      		reti
 390               		.size	__vector_1, .-__vector_1
 391               	.Lscope2:
 392               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 393               		.stabd	78,0,0
 394               		.stabs	"initialize:F(0,49)",36,0,138,initialize
 395               	.global	initialize
 396               		.type	initialize, @function
 397               	initialize:
 398               		.stabd	46,0,0
 132:main.c        **** 
 133:main.c        **** 
 134:main.c        **** 
 135:main.c        **** 
 136:main.c        **** /////////////////
 137:main.c        **** // Initalize
 138:main.c        **** void initialize(void){
 399               		.stabn	68,0,138,.LM31-.LFBB3
 400               	.LM31:
 401               	.LFBB3:
 402               	/* prologue: function */
GAS LISTING /tmp/ccycqgnB.s 			page 14


 403               	/* frame size = 0 */
 404               	/* stack size = 0 */
 405               	.L__stack_usage = 0
 139:main.c        ****    // enable PORTA to output
 140:main.c        ****    DDRA = 0xFF; // set PORTA to all outputs // to use other MCU you need to change this
 406               		.stabn	68,0,140,.LM32-.LFBB3
 407               	.LM32:
 408 010c 8FEF      		ldi r24,lo8(-1)
 409 010e 8ABB      		out 0x1a,r24
 141:main.c        **** 
 142:main.c        **** 
 143:main.c        **** 	
 144:main.c        ****    // ATtiny26
 145:main.c        ****    //    MCUCR: MCU Control Register
 146:main.c        ****    //       ISC01=1 ISC00=1 The rising edge of INT0 generates an interrupt request.
 147:main.c        ****    //    GIMSK: General Interrupt Mask Register
 148:main.c        ****    //    GIFR: General Interrupt Flag Register
 149:main.c        ****    //    INTF0: 6
 150:main.c        **** 
 151:main.c        ****    MCUCR |= (1<<ISC00); //rising edge // to use other MCU you need to change this
 410               		.stabn	68,0,151,.LM33-.LFBB3
 411               	.LM33:
 412 0110 85B7      		in r24,0x35
 413 0112 8160      		ori r24,lo8(1)
 414 0114 85BF      		out 0x35,r24
 152:main.c        ****    MCUCR |= (1<<ISC01); //rising edge // to use other MCU you need to change this
 415               		.stabn	68,0,152,.LM34-.LFBB3
 416               	.LM34:
 417 0116 85B7      		in r24,0x35
 418 0118 8260      		ori r24,lo8(2)
 419 011a 85BF      		out 0x35,r24
 153:main.c        ****    GIMSK |= (1<<INT0); // enable INT0 // to use other MCU you need to change this
 420               		.stabn	68,0,153,.LM35-.LFBB3
 421               	.LM35:
 422 011c 8BB7      		in r24,0x3b
 423 011e 8064      		ori r24,lo8(64)
 424 0120 8BBF      		out 0x3b,r24
 154:main.c        **** 
 155:main.c        ****    sei();     // Enable global interrupts by setting global interrupt enable bit in SREG
 425               		.stabn	68,0,155,.LM36-.LFBB3
 426               	.LM36:
 427               	/* #APP */
 428               	 ;  155 "main.c" 1
 429 0122 7894      		sei
 430               	 ;  0 "" 2
 156:main.c        **** 
 157:main.c        ****    // turn on LED indicator for power on
 158:main.c        ****    PORTA |= (1<<PIN_LED_PWR_ON); // to use other MCU you need to change this
 431               		.stabn	68,0,158,.LM37-.LFBB3
 432               	.LM37:
 433               	/* #NOAPP */
 434 0124 DC9A      		sbi 0x1b,4
 435 0126 0895      		ret
 436               		.size	initialize, .-initialize
 437               	.Lscope3:
 438               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 439               		.stabd	78,0,0
GAS LISTING /tmp/ccycqgnB.s 			page 15


 440               		.section	.text.startup,"ax",@progbits
 441               		.stabs	"main:F(0,1)",36,0,165,main
 442               	.global	main
 443               		.type	main, @function
 444               	main:
 445               		.stabd	46,0,0
 159:main.c        **** 
 160:main.c        **** }
 161:main.c        **** 
 162:main.c        **** 
 163:main.c        **** ///////////
 164:main.c        **** // Main
 165:main.c        **** int main(void)
 166:main.c        **** {
 446               		.stabn	68,0,166,.LM38-.LFBB4
 447               	.LM38:
 448               	.LFBB4:
 449               	/* prologue: function */
 450               	/* frame size = 0 */
 451               	/* stack size = 0 */
 452               	.L__stack_usage = 0
 167:main.c        ****    initialize();
 453               		.stabn	68,0,167,.LM39-.LFBB4
 454               	.LM39:
 455 0000 00D0      		rcall initialize
 456               	.L16:
 457               	.LBB27:
 458               	.LBB28:
 459               		.stabs	"/usr/lib/avr/include/util/delay.h",132,0,0,.Ltext7
 460               	.Ltext7:
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
GAS LISTING /tmp/ccycqgnB.s 			page 16


 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
GAS LISTING /tmp/ccycqgnB.s 			page 17


 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 461               		.stabn	68,0,276,.LM40-.LFBB4
 462               	.LM40:
 463 0002 83E0      		ldi r24,lo8(3)
 464 0004 8A95      	1:	dec r24
 465 0006 01F4      		brne 1b
 466 0008 0000      		nop
 467 000a 00C0      		rjmp .L16
 468               	.LBE28:
 469               	.LBE27:
 470               		.size	main, .-main
 471               	.Lscope4:
 472               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 473               		.stabd	78,0,0
 474               	.global	beep_length
 475               		.section	.rodata
 476               		.type	beep_length, @object
 477               		.size	beep_length, 20
 478               	beep_length:
 479 0000 0100      		.word	1
 480 0002 0700      		.word	7
 481 0004 0300      		.word	3
 482 0006 0400      		.word	4
 483 0008 0600      		.word	6
 484 000a 0200      		.word	2
 485 000c 0400      		.word	4
 486 000e 0800      		.word	8
 487 0010 0200      		.word	2
 488 0012 0500      		.word	5
 489               		.stabs	"beep_length:G(0,50)=ar(0,51)=r(0,51);0;0177777;;0;9;(0,52)=k(0,1)",32,0,45,0
 490               		.text
 491               		.stabs	"",100,0,0,.Letext0
 492               	.Letext0:
 493               		.ident	"GCC: (GNU) 5.4.0"
 494               	.global __do_copy_data
GAS LISTING /tmp/ccycqgnB.s 			page 18


DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccycqgnB.s:2      *ABS*:000000000000003d __SP_L__
     /tmp/ccycqgnB.s:3      *ABS*:000000000000003f __SREG__
     /tmp/ccycqgnB.s:4      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccycqgnB.s:5      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccycqgnB.s:106    .text:0000000000000000 animal_det
     /tmp/ccycqgnB.s:478    .rodata:0000000000000000 beep_length
     /tmp/ccycqgnB.s:341    .text:00000000000000c6 __vector_1
     /tmp/ccycqgnB.s:397    .text:000000000000010c initialize
     /tmp/ccycqgnB.s:444    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
__divmodhi4
__do_copy_data
